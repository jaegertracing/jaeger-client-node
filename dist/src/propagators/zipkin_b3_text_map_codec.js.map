{"version":3,"sources":["../../../src/propagators/zipkin_b3_text_map_codec.js"],"names":["constants","ZIPKIN_PARENTSPAN_HEADER","ZIPKIN_SPAN_HEADER","ZIPKIN_TRACE_HEADER","ZIPKIN_SAMPLED_HEADER","ZIPKIN_FLAGS_HEADER","ZipkinB3TextMapCodec","options","_urlEncoding","urlEncoding","_baggagePrefix","baggagePrefix","TRACER_BAGGAGE_HEADER_PREFIX","toLowerCase","_metrics","metrics","value","encodeURIComponent","indexOf","_decodeURIValue","isNaN","parseInt","decodeURIComponent","e","carrier","baggage","flags","debugId","parentId","spanId","traceId","key","hasOwnProperty","lowerKey","_decodeValue","SAMPLED_MASK","DEBUG_MASK","JAEGER_DEBUG_HEADER","JAEGER_BAGGAGE_HEADER","startsWith","keyWithoutPrefix","substring","length","_isValidZipkinId","decodingErrors","increment","withStringIds","spanContext","traceIdStr","parentIdStr","spanIdStr","isDebug","isSampled","_encodeValue"],"mappings":"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","file":"zipkin_b3_text_map_codec.js","sourcesContent":["// @flow\n// Copyright (c) 2017 The Jaeger Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport * as constants from '../constants.js';\nimport Metrics from '../metrics/metrics.js';\nimport NoopMetricFactory from '../metrics/noop/metric_factory';\nimport SpanContext from '../span_context.js';\nimport Utils from '../util.js';\nimport { parseCommaSeparatedBaggage } from '../propagators/baggage';\n\nconst ZIPKIN_PARENTSPAN_HEADER = 'x-b3-parentspanid';\nconst ZIPKIN_SPAN_HEADER = 'x-b3-spanid';\nconst ZIPKIN_TRACE_HEADER = 'x-b3-traceid';\nconst ZIPKIN_SAMPLED_HEADER = 'x-b3-sampled';\nconst ZIPKIN_FLAGS_HEADER = 'x-b3-flags';\n\nexport default class ZipkinB3TextMapCodec {\n    _urlEncoding: boolean;\n    _baggagePrefix: string;\n    _metrics: any;\n\n    constructor(options: any = {}) {\n        this._urlEncoding = !!options.urlEncoding;\n        this._baggagePrefix = options.baggagePrefix || constants.TRACER_BAGGAGE_HEADER_PREFIX;\n        this._baggagePrefix = this._baggagePrefix.toLowerCase();\n        this._metrics = options.metrics || new Metrics(new NoopMetricFactory());\n    }\n\n    _encodeValue(value: string): string {\n        if (this._urlEncoding) {\n            return encodeURIComponent(value);\n        }\n\n        return value;\n    }\n\n    _decodeValue(value: string): string {\n        // only use url-decoding if there are meta-characters '%'\n        if (this._urlEncoding && value.indexOf('%') > -1) {\n            return this._decodeURIValue(value);\n        }\n\n        return value;\n    }\n\n    _isValidZipkinId(value: string): boolean {\n        // Validates a zipkin trace/spanID by attempting to parse it as a\n        // string of hex digits. This \"validation\" is not entirely rigorous,\n        // but equivalent to what is performed in the TextMapCodec.\n        //\n        // Note: due to the way parseInt works, this does not guarantee that\n        // the string is composed *entirely* of hex digits.\n        //\n        // > If parseInt encounters a character that is not a numeral in the\n        // > specified radix, it ignores it and all succeeding characters and\n        // > returns the integer value parsed up to that point.\n        //\n        // Note: The Number type in JS cannot represent the full range of 64bit\n        // unsigned ints, so using parseInt() on strings representing 64bit hex\n        // numbers only returns an approximation of the actual value.\n        // Fortunately, we do not depend on the returned value, we are only\n        // using it to validate that the string is a valid hex number (which is\n        // faster than doing it manually).  We cannot use\n        // Int64(numberValue).toBuffer() because it throws exceptions on bad\n        // strings.\n        if (!value) {\n            return true\n        }\n\n        return !isNaN(parseInt(value, 16));\n    }\n\n    _decodeURIValue(value: string): string {\n        // unfortunately, decodeURIComponent() can throw 'URIError: URI malformed' on bad strings\n        try {\n            return decodeURIComponent(value);\n        } catch (e) {\n            return value;\n        }\n    }\n\n    extract(carrier: any): ?SpanContext {\n        let baggage = {};\n        let flags = 0;\n        let debugId = '';\n        let parentId = '';\n        let spanId = '';\n        let traceId = '';\n\n        for (let key in carrier) {\n            if (carrier.hasOwnProperty(key)) {\n                let lowerKey = key.toLowerCase();\n\n                switch (lowerKey) {\n                    case ZIPKIN_PARENTSPAN_HEADER:\n                        parentId = this._decodeValue(carrier[ZIPKIN_PARENTSPAN_HEADER]);\n                        break;\n                    case ZIPKIN_SPAN_HEADER:\n                        spanId = this._decodeValue(carrier[ZIPKIN_SPAN_HEADER]);\n                        break;\n                    case ZIPKIN_TRACE_HEADER:\n                        traceId = this._decodeValue(carrier[ZIPKIN_TRACE_HEADER]);\n                        break;\n                    case ZIPKIN_SAMPLED_HEADER:\n                        flags = flags | constants.SAMPLED_MASK;\n                        break;\n                    case ZIPKIN_FLAGS_HEADER:\n                        // Per https://github.com/openzipkin/b3-propagation\n                        //   \"Debug is encoded as X-B3-Flags: 1\"\n                        // and\n                        //   \"Debug implies Sampled.\"\n                        if (carrier[key] === '1') {\n                            flags = flags | constants.SAMPLED_MASK | constants.DEBUG_MASK;\n                        }\n                        break;\n                    case constants.JAEGER_DEBUG_HEADER:\n                        debugId = this._decodeValue(carrier[constants.JAEGER_DEBUG_HEADER]);\n                        break;\n                    case constants.JAEGER_BAGGAGE_HEADER:\n                        parseCommaSeparatedBaggage(baggage, this._decodeValue(carrier[key]));\n                        break;\n                    default:\n                        if (Utils.startsWith(lowerKey, this._baggagePrefix)) {\n                            let keyWithoutPrefix = key.substring(this._baggagePrefix.length);\n                            baggage[keyWithoutPrefix] = this._decodeValue(carrier[key]);\n                        }\n                }\n            }\n        }\n\n        if ((!this._isValidZipkinId(traceId)) ||\n            (!this._isValidZipkinId(spanId)) ||\n            (!this._isValidZipkinId(parentId))) {\n                // Use a context devoid of trace/span/parentSpan IDs (to be\n                // consistent with the default codec behavior), and increment a\n                // metric\n                traceId = spanId = parentId = '';\n                this._metrics.decodingErrors.increment(1);\n            }\n\n        return SpanContext.withStringIds(traceId, spanId, parentId, flags, baggage, debugId);\n    }\n\n    inject(spanContext: SpanContext, carrier: any): void {\n        carrier[ZIPKIN_TRACE_HEADER] = spanContext.traceIdStr;\n        carrier[ZIPKIN_PARENTSPAN_HEADER] = spanContext.parentIdStr;\n        carrier[ZIPKIN_SPAN_HEADER] = spanContext.spanIdStr;\n\n        if (spanContext.isDebug()) {\n           carrier[ZIPKIN_FLAGS_HEADER] = '1';\n        } else {\n            // Only set the zipkin sampled header if we're NOT using debug.\n            // Per https://github.com/openzipkin/b3-propagation\n            //   \"Since Debug implies Sampled, so don't also send \"X-B3-Sampled: 1\"\n            carrier[ZIPKIN_SAMPLED_HEADER] = spanContext.isSampled() ? '1' : '0';\n        }\n\n        let baggage = spanContext.baggage;\n        for (let key in baggage) {\n            if (baggage.hasOwnProperty(key)) {\n                let value = this._encodeValue(spanContext.baggage[key]);\n                carrier[`${this._baggagePrefix}${key}`] = value;\n            }\n        }\n    }\n}\n"]}