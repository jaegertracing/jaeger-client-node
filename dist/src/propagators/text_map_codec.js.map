{"version":3,"sources":["../../../src/propagators/text_map_codec.js"],"names":["constants","TextMapCodec","options","_urlEncoding","urlEncoding","_contextKey","contextKey","TRACER_STATE_HEADER_NAME","toLowerCase","_baggagePrefix","baggagePrefix","TRACER_BAGGAGE_HEADER_PREFIX","_metrics","metrics","value","encodeURIComponent","indexOf","_decodeURIValue","decodeURIComponent","e","carrier","spanContext","baggage","debugId","key","hasOwnProperty","lowerKey","decodedContext","fromString","_decodeValue","decodingErrors","increment","JAEGER_DEBUG_HEADER","JAEGER_BAGGAGE_HEADER","_parseCommaSeparatedBaggage","startsWith","keyWithoutPrefix","substring","length","stringSpanContext","toString","_encodeValue","values","split","forEach","keyVal","splitKeyVal","trim"],"mappings":"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","file":"text_map_codec.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport * as constants from '../constants.js';\nimport Metrics from '../metrics/metrics.js';\nimport NoopMetricFactory from '../metrics/noop/metric_factory';\nimport SpanContext from '../span_context.js';\nimport Utils from '../util.js';\n\nexport default class TextMapCodec {\n    _urlEncoding: boolean;\n    _contextKey: string;\n    _baggagePrefix: string;\n    _metrics: any;\n\n    constructor(options: any = {}) {\n        this._urlEncoding = !!options.urlEncoding;\n        this._contextKey = options.contextKey || constants.TRACER_STATE_HEADER_NAME;\n        this._contextKey = this._contextKey.toLowerCase();\n        this._baggagePrefix = options.baggagePrefix || constants.TRACER_BAGGAGE_HEADER_PREFIX;\n        this._baggagePrefix = this._baggagePrefix.toLowerCase();\n        this._metrics = options.metrics || new Metrics(new NoopMetricFactory());\n    }\n\n    _encodeValue(value: string): string {\n        if (this._urlEncoding) {\n            return encodeURIComponent(value);\n        }\n\n        return value;\n    }\n\n    _decodeValue(value: string): string {\n        // only use url-decoding if there are meta-characters '%'\n        if (this._urlEncoding && value.indexOf('%') > -1) {\n            return this._decodeURIValue(value);\n        }\n\n        return value;\n    }\n\n    _decodeURIValue(value: string): string {\n        // unfortunately, decodeURIComponent() can throw 'URIError: URI malformed' on bad strings\n        try {\n            return decodeURIComponent(value);\n        } catch (e) {\n            return value;\n        }\n    }\n\n    extract(carrier: any): ?SpanContext {\n        let spanContext = new SpanContext();\n        let baggage = {};\n        let debugId = '';\n\n        for (let key in carrier) {\n            if (carrier.hasOwnProperty(key)) {\n                let lowerKey = key.toLowerCase();\n                if (lowerKey === this._contextKey) {\n                    let decodedContext = SpanContext.fromString(this._decodeValue(carrier[key]));\n                    if (decodedContext === null) {\n                        this._metrics.decodingErrors.increment(1);\n                    } else {\n                        spanContext = decodedContext;\n                    }\n                } else if (lowerKey === constants.JAEGER_DEBUG_HEADER) {\n                    debugId = this._decodeValue(carrier[key]);\n                } else if (lowerKey === constants.JAEGER_BAGGAGE_HEADER) {\n                    this._parseCommaSeparatedBaggage(baggage, this._decodeValue(carrier[key]));\n                } else if (Utils.startsWith(lowerKey, this._baggagePrefix)) {\n                    let keyWithoutPrefix = key.substring(this._baggagePrefix.length);\n                    baggage[keyWithoutPrefix] = this._decodeValue(carrier[key]);\n                }\n            }\n        }\n\n        spanContext.debugId = debugId;\n        spanContext.baggage = baggage;\n        return spanContext;\n    }\n\n    inject(spanContext: SpanContext, carrier: any): void {\n        let stringSpanContext = spanContext.toString();\n        carrier[this._contextKey] = stringSpanContext; // no need to encode this\n\n        let baggage = spanContext.baggage;\n        for (let key in baggage) {\n            if (baggage.hasOwnProperty(key)) {\n                let value = this._encodeValue(spanContext.baggage[key]);\n                carrier[`${this._baggagePrefix}${key}`] = value;\n            }\n        }\n    }\n\n    // Parse comma separated key=value pair list and add to baggage.\n    // E.g. \"key1=value1, key2=value2, key3 = value3\"\n    // is converted to map[string]string { \"key1\" : \"value1\",\n    //                                     \"key2\" : \"value2\",\n    //                                     \"key3\" : \"value3\" }\n    _parseCommaSeparatedBaggage(baggage: any, values: string): void {\n        values.split(',').forEach((keyVal) => {\n            let splitKeyVal: Array<string> = keyVal.trim().split('=');\n            if (splitKeyVal.length == 2) {\n                baggage[splitKeyVal[0]] = splitKeyVal[1];\n            }\n        });\n    }\n}\n"]}