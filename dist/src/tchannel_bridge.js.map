{"version":3,"sources":["../../src/tchannel_bridge.js"],"names":["constants","TCHANNEL_TRACING_PREFIX","TChannelBridge","tracer","options","_tracer","equal","_codec","urlEncoding","contextKey","TRACER_STATE_HEADER_NAME","baggagePrefix","TRACER_BAGGAGE_HEADER_PREFIX","_contextFactory","contextFactory","_getSpan","getSpan","ctx","_setSpan","setSpan","span","callback","err","res","setTag","Tags","ERROR","log","finish","handlerFunc","perProcessOptions","request","headers","body","context","operationName","arg1","_extractSpan","PEER_SERVICE","callerName","hostPort","remoteAddr","split","length","PEER_PORT","parseInt","as","headerKeys","Object","keys","i","key","hasOwnProperty","startsWith","wrappingCallback","_tchannelCallbackWrapper","bind","wrappedSend","channel","req","endpoint","childOf","clientSpan","startSpan","serviceName","SPAN_KIND","SPAN_KIND_RPC_CLIENT","inject","call","wrappedRequestMethod","requestOptions","parent","makeFakeTChannelParentSpan","tchannelRequest","spanContext","send","_wrapTChannelRequest","_wrapTChannelSend","traceContext","extract","tags","SPAN_KIND_RPC_SERVER","id","traceid","parentid","flags"],"mappings":"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","file":"tchannel_bridge.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport assert from 'assert';\nimport * as constants from './constants';\nimport DefaultContext from './default_context';\nimport Span from './span';\nimport SpanContext from './span_context';\nimport Utils from './util';\nimport opentracing from 'opentracing';\nimport Tracer from './tracer';\nimport TextMapCodec from './propagators/text_map_codec';\n\nlet TCHANNEL_TRACING_PREFIX = '$tracing$';\n\nexport default class TChannelBridge {\n    _tracer: Tracer;\n    _codec: TextMapCodec;\n    _contextFactory: Function;\n    _getSpan: Function;\n    _setSpan: Function;\n\n    /**\n     * @param {Object} [tracer] - Jaeger Tracer\n     * @param {Object} [options] - options\n     * @param {Function} [options.contextFactory] - function used to create new Context object instead of DefaultContext\n     * @param {Function} [options.getSpan] - function(ctx): Span - used to read Span from Context object; default is ctx.getSpan()\n     * @param {Function} [options.setSpan] - function(ctx, span): void - used to set Span on the Context object; default is ctx.setSpan(span)\n     */\n    constructor(tracer: Tracer, options: any = {}) {\n        this._tracer = tracer;\n        assert.equal('object', typeof(options), 'options must be an object');\n        this._codec = new TextMapCodec({\n            urlEncoding: false,\n            contextKey: TCHANNEL_TRACING_PREFIX + constants.TRACER_STATE_HEADER_NAME,\n            baggagePrefix: TCHANNEL_TRACING_PREFIX + constants.TRACER_BAGGAGE_HEADER_PREFIX\n        });\n        this._contextFactory = options.contextFactory || function() { return new DefaultContext(); };\n        this._getSpan = options.getSpan || function(ctx) { return ctx.getSpan(); };\n        this._setSpan = options.setSpan || function(ctx, span) { return ctx.setSpan(span); };\n    }\n\n    _tchannelCallbackWrapper(span: Span, callback: Function, err: any, res: any) {\n        if (err) {\n            span.setTag(opentracing.Tags.ERROR, true);\n            span.log('error_msg', err);\n        }\n\n        span.finish();\n        return callback(err, res);\n    }\n\n    /**\n     * Wraps a tchannel handler, and takes a context in order to populate the incoming context\n     * with a span.\n     *\n     * @param {Function} [handlerFunc] - a tchannel handler function that responds to an incoming request.\n     * @param {Object} [options] - options to be passed to a span on creation.\n     * @returns {Function} - a function that wrapps the handler in order to automatically populate\n     * a the handler's context with a span.\n     **/\n    tracedHandler(handlerFunc: any, options: any = {}): Function {\n        return (perProcessOptions, request, headers, body, callback) => {\n            let context: Context = this._contextFactory();\n            let operationName: string = options.operationName || request.arg1;\n            let span: Span = this._extractSpan(operationName, headers);\n\n            // set tags\n            span.setTag(opentracing.Tags.PEER_SERVICE, request.callerName);\n            let hostPort: Array<string> = request.remoteAddr.split(':');\n            if (hostPort.length == 2) {\n                span.setTag(opentracing.Tags.PEER_PORT, parseInt(hostPort[1]));\n            }\n            if (request.headers && request.headers.as) {\n                span.setTag('as', request.headers.as);\n            }\n\n            this._setSpan(context, span);\n\n            // remove headers prefixed with $tracing$\n            let headerKeys: Array<string> = Object.keys(headers);\n            for (let i = 0; i < headerKeys.length; i++) {\n                let key = headerKeys[i];\n                if (headers.hasOwnProperty(key) && Utils.startsWith(key, TCHANNEL_TRACING_PREFIX)) {\n                    delete headers[key];\n                }\n            }\n\n            let wrappingCallback: Function = this._tchannelCallbackWrapper.bind(null, span, callback);\n            request.context = context;\n            handlerFunc(perProcessOptions, request, headers, body, wrappingCallback);\n        };\n    }\n\n    _wrapTChannelSend(wrappedSend: Function, channel: any, req: any, endpoint: string, headers: any, body: any, callback: Function) {\n        headers = headers || {};\n        let context: Context = req.context || this._contextFactory();\n        let childOf: Span = this._getSpan(context);\n        let clientSpan = this._tracer.startSpan(endpoint, {\n            childOf: childOf // ok if null, will start a new trace\n        });\n        clientSpan.setTag(opentracing.Tags.PEER_SERVICE, req.serviceName);\n        clientSpan.setTag(opentracing.Tags.SPAN_KIND, opentracing.Tags.SPAN_KIND_RPC_CLIENT);\n        this.inject(clientSpan.context(), headers);\n\n        // wrap callback so that span can be finished as soon as the response is received\n        let wrappingCallback: Function = this._tchannelCallbackWrapper.bind(null, clientSpan, callback);\n\n        return wrappedSend.call(channel, req, endpoint, headers, body, wrappingCallback);\n    }\n\n    _wrapTChannelRequest(channel: any, wrappedRequestMethod: any, requestOptions: any) {\n        // We set the parent to a span with trace_id zero, so that tchannel's\n        // outgoing tracing frame also has a trace id of zero.\n        // This forces other tchannel implementations to rely on the headers for the trace context.\n        requestOptions.parent = { span: TChannelBridge.makeFakeTChannelParentSpan() };\n\n        let tchannelRequest: any = wrappedRequestMethod.call(channel, requestOptions);\n        tchannelRequest.context = requestOptions.context;\n        return tchannelRequest;\n    }\n\n    /**\n     * Encode given span context as tchannel headers and store into the headers dictionary.\n     * @param {Object} spanContext - Jaeger SpanContext.\n     * @returns {Object} headers - a dictionary with TChannel application headers.\n     */\n    inject(spanContext: any, headers: any) {\n        this._codec.inject(spanContext, headers);\n    }\n\n    /**\n     * A function that wraps a json, or thrift encoded channel, in order to populate\n     * the outgoing headers with trace context, and baggage information.\n     *\n     * @param {Object} channel - the encoded channel to be wrapped for tracing.\n     * @returns {Object} channel - the trace wrapped channel.\n     * */\n    tracedChannel(channel: any): any {\n        let wrappedSend = channel.send;\n        let wrappedRequestMethod = channel.channel.request;\n\n        // We are patching the top level channel request method, not the encoded request method.\n        channel.channel.request = this._wrapTChannelRequest.bind(this, channel.channel, wrappedRequestMethod);\n\n        channel.send = this._wrapTChannelSend.bind(this, wrappedSend, channel);\n        return channel;\n    }\n\n    static makeFakeTChannelParentSpan(): any {\n        return {\n            id: [0, 0],\n            traceid: [0, 0],\n            parentid: [0, 0],\n            flags: 0\n        };\n    }\n\n    _extractSpan(operationName: string, headers: any): Span {\n        let traceContext: ?SpanContext = this._codec.extract(headers);\n        let tags: any = {};\n        tags[opentracing.Tags.SPAN_KIND] = opentracing.Tags.SPAN_KIND_RPC_SERVER;\n        let options: any = {\n            childOf: traceContext,\n            tags: tags\n        }\n        let span: Span = this._tracer.startSpan(operationName, options);\n        return span;\n    }\n}\n"]}